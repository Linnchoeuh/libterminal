/**
 * @file terminal.h
 * @author Lenny Vigeon (lenny.vigeon@ecole-89.com)
 * @brief Useful set of function to create a terminal and interact with
 * @version 1.0
 * @date 20-02-2022
 */

#ifndef		__TERMINAL_H__
#define		__TERMINAL_H__

#include	<stdlib.h>
#include	<unistd.h>
#include	<stdbool.h>
#include	<sys/wait.h>
#include	<signal.h>

#include 	"terminal_baselib.h"
#include 	"terminal_strsplit.h"

/**
 * @brief Read STDIN until find a '\\n' and return a (char *) of it.
 * The '\\n' character is not kept.
 *
 * @param block_sigint Ignore CTRL+C (SIGINT) signal
 * @return char* On success a char with what was written in STDIN,
 * NULL if CTRL+D is invoked or if it fails.
 */
char		*read_entry(bool		block_sigint);


/**
 * @brief Read STDIN until find a '\\n' and
 * return a (char **) with NULL terminator at the end.
 * The (char **) separation is related to the spaces
 * the user puts on STDIN.
 * The '\\n' character is not kept.
 *
 * @param entry_header Example : bash> [user message]
 * @param block_sigint Block CTRL+C emited signal.
 * @return char**
 */
char		**get_entry(char		*entry_header,
			    bool		block_sigint);


/**
 * @brief Makes possible to execute every program in the computer.
 * It handle installed and local program,
 * and generate the path to launch them when it's necessary.
 *
 * @param cmd A char* that contains the command and it's parameter
 * @param env Environment variable
 * @return int Executed program output
 */
int		term_execute(const char		*cmd,
			     char		**env);


/**
 * @brief Change directory function (cd), works the same as
 * the real cd command.
 *
 * @param path Where you want to go.
 * @param env Environment variable (Optional but this remove feature)
 * @return true if cd moved to the aked directory,
 * false if it failed to go to the asked directory.
 */
bool		term_cd(char			*path,
			char			**env);


// env var manipulation


/**
 * @brief Get the content of a environment variable.
 *
 * @param var_name The name of the environment variable.
 * @param env Environment variable.
 * @return char* The content of the requested environment
 * variable, if it doesn't exit return NULL.
 */
char		*env_get_var(char		*var_name,
			     char		**env);


/**
 * @brief Set a new value in the requested variable.
 * You have to dynamically allocate the env var,
 * if not it must cause memory issues.
 *
 * @param var_name The name of the environment variable.
 * @param content What you want to put in the variable.
 * @param env Environment variable.
 * @return true on succes,
 * false if the variable doesn't exist or memory allocation failed.
 */
bool		env_set_var(char		*var_name,
			    char		*content,
			    char		**env);


/**
 * @brief Specially created to get the PATH variable content.
 *
 * @param env Environment variable.
 * @return char** on success with all path splitted,
 * NULL if the variable PATH doesn't exist or memory allocation failed.
 */
char		**env_get_path(char		**env);


/**
 * @brief Replace for example a "$PWD" by "/home/"
 * in the variable split_arg (char **).
 *
 * @param split_arg The target of the modification
 * @param env Environment variable to get the content of the alias.
 * @return true on success,
 * false if it fails.
 */
bool		env_replace_var_alias(char	**split_arg,
				      char	**env);


/**
 * @brief Create a dynamically memory allocation of the env
 * variable sub pointer (env[x] is allocated not env).
 *
 * @param env Environment variable.
 * @return true on success,
 * false on memory allocation failure
 */
bool		env_enable_modification(char	**env);


/**
 * @brief To free an environnement variable generated by
 * env_enable_modification() function.
 *
 * @param env Environment variable dynamically memory allocated to free.
 */
void		env_free_var(char		**env);


#endif  /*      __TERMINAL_H__    */

